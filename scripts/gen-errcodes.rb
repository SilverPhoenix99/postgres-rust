
require 'pathname'
require_relative 'minimal_perfect_hash'

class ErrCodesGenerator

  def self.run!(input, output_root, enums_file: 'enums.rs', variants_file: 'variants.rs')
    output_root = Pathname(output_root)
    enums_file = output_root / enums_file
    variants_file = output_root / variants_file
    new(input:, enums_file:, variants_file:).run!
  end

  def initialize(input:, enums_file:, variants_file:)
    @input = Pathname(input)
    @enums_file = Pathname(enums_file)
    @variants_file = Pathname(variants_file)
  end

  def run!
    init_codes_hash

    enums = render_enums
    @enums_file.write(enums)

    variants = render_variants
    @variants_file.write(variants)

    nil
  end

  def init_codes_hash
    return if @table

    @codes = errcodes
      .reject { |category, _| category == 'S' }
      .values
      .map(&:values)
      .flatten
      .reject { |code| aliases.dig(code[:sqlstate], code[:name]) }
      .to_h { |code| [code[:repr], code] }

    @table = MinimalPerfectHash.generate!(@codes.keys)

    nil
  end

  def render_enums
    enums = errcodes.flat_map do |category, sections|

      category = case category
        when 'S' then 'Success'
        when 'W' then 'Warning'
        else 'Error'
      end

      sections = sections.flat_map do |section, codes|

        section = "/* #{section} */"

        codes = codes
          .reject { |code| aliases.dig(code[:sqlstate], code[:name]) }
          .flat_map do |code|
            sqlstate = code[:sqlstate]
            repr = code[:repr]
            name = code[:name]

            akas = if aliases.dig(sqlstate, :base_code) == name
              aliases[sqlstate]
                .keys
                .reject { |k| k == :base_code }
                .map { |a| "/// Alias: `#{a}`<p/>" }
            end

            [
              *akas,
              "/** SQLSTATE: `#{sqlstate}` */ #{name} = 0x#{repr.to_s(16)},"
            ]
          end

        [section, *codes].map do |line|
          "    #{line}"
        end
          .prepend('')
      end

      [
        '#[repr(u32)]',
        '#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]',
        "pub enum #{category}SqlState {",
        *sections,
        '}',
        ''
      ]
    end

    lines = [
      "// Automatically generated by #{File.basename(__FILE__)} at #{Time.now.utc}",
      '//',
      '// DO NOT EDIT MANUALLY !!!',
      '//',
      '',
      *enums
    ]

    lines.join("\n")
  end

  def render_variants

    [
      "// Automatically generated by #{File.basename(__FILE__)} at #{Time.now.utc}",
      '//',
      '// DO NOT EDIT MANUALLY !!!',
      '//',
      '',
      'pub(super) const MAP: mphf::Map<u32, ()> = mphf::Map::new(&SALTS, &ENTRIES);',
      '',
      *render_variants_array,
      '',
      *render_salts,
      '',
      'use crate::mphf;',
      ''
    ].join("\n")
  end

  def render_variants_array

    variants = @table.slots
      .map do |code, slot|
        @codes[code].tap { |c| c[:slot] = slot }
      end
      .sort_by { |code| code[:slot] }
      .map do |code|
        repr = '%08x' % code[:repr]
        sqlstate = code[:sqlstate]
        name = code[:name]
        "    (0x#{repr}, ()), // #{sqlstate} #{name}"
      end

    [
      "const ENTRIES: [(u32, ()); #{variants.size}] = [",
      *variants,
      '];'
    ]
  end

  def render_salts

    values = @table.salts.each_slice(16)
      .map do |slice|
        slice = slice.map { |i| '%4s' % i }.join(', ')
        "    #{slice},"
      end

    [
      "const SALTS: [i16; #{@table.salts.size}] = [",
      *values,
      '];'
    ]
  end

  def aliases
    @aliases ||= errcodes
      .values
      .map(&:values)
      .flatten
      .group_by { |code| code[:sqlstate] }
      .select { |_, codes| codes.count > 1 }
      .transform_values do |codes|
        codes.each_with_object({}) do |code, h|
          if code[:spec_name].nil?
            h[code[:name]] = :alias
          else
            h[:base_code] = code[:name]
          end
        end
      end
  end

  def errcodes
    @errcodes ||= lines
      .chunk_while { !_2.match(/^\s*Section:/) }
      .with_object(Hash.new { |h, k| h[k] = Hash.new }) do |(section, *codes), h|

        codes = codes
          .map(&:split)
          .map do |sqlstate, category, macro_name, spec_name|
            repr = sqlstate.bytes
              .map { |b| b - '0'.ord }
              .reduce { |acc, b| (acc << 6) | b }

            name = macro_name[8..-1] # remove 'ERRCODE_'
            name = name.downcase.gsub(/(?:^|_)(.)/) { |m| m[-1].upcase }
            { sqlstate:, category:, name:, spec_name:, repr: }
          end

        category = codes.first[:category]

        h[category][section] = codes
      end
  end

  def lines
    @lines ||= @input.readlines.tap do |f|
      f.reject! { _1.match?(/^\s*(#|$)/) }
    end.map!(&:chomp!);
  end

end

ErrCodesGenerator.run!($ARGV[0], $ARGV[1]) if __FILE__ == $PROGRAM_NAME
