
require 'pathname'

class ErrCodesGenerator

  def self.run!(input, output_root, enums_file: 'enums.rs', variant_sets_file: 'variant_sets.rs')
    output_root = Pathname(output_root)
    enums_file = output_root / enums_file
    variant_sets_file = output_root / variant_sets_file
    new(input:, enums_file:, variant_sets_file:).run!
  end

  def initialize(input:, enums_file:, variant_sets_file:)
    @input = Pathname(input)
    @enums_file = Pathname(enums_file)
    @variant_sets_file = Pathname(variant_sets_file)
  end

  def run!
    enums = render_enums
    @enums_file.write(enums)

    variant_sets = render_variant_sets
    @variant_sets_file.write(variant_sets)

    nil
  end

  def render_enums
    errcodes.flat_map do |category, sections|

      category = case category
        when 'S' then 'Success'
        when 'W' then 'Warning'
        else 'Error'
      end

      sections = sections.flat_map do |section, codes|

        section = "/* #{section} */"

        codes = codes
          .reject { |code| aliases.dig(code[:sqlstate], code[:name]) }
          .flat_map do |code|
            sqlstate = code[:sqlstate]
            repr = code[:repr]
            name = code[:name]

            akas = if aliases.dig(sqlstate, :base_code) == name
              aliases[sqlstate]
                .keys
                .reject { |k| k == :base_code }
                .map { |a| "/// Alias: `#{a}`<p/>" }
            end

            [
              *akas,
              "/** SQLSTATE: `#{sqlstate}` */ #{name} = 0x#{repr.to_s(16)},"
            ]
          end

        [section, *codes].map do |line|
          "    #{line}"
        end
          .prepend('')
      end

      [
        '#[repr(u32)]',
        '#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]',
        "pub enum #{category}SqlState {",
        *sections,
        "}\n"
      ]
    end
      .prepend("// Automatically generated by #{File.basename(__FILE__)} at #{Time.now.utc}\n")
      .join("\n")
  end

  def render_variant_sets
    errcodes
      .reject { |category, _| category == 'S' }
      .map do |category, sections|

        category = category == 'W' ? 'WARNING' : 'ERROR'

        codes = sections
          .values
          .flatten
          .reject { |code| aliases.dig(code[:sqlstate], code[:name]) }
          .map do |code|
            repr = '%08x' % code[:repr]
            sqlstate = code[:sqlstate]
            name = code[:name]
            "    0x#{repr}_u32, // #{sqlstate} #{name}"
          end

        [
          "pub(super) static #{category}_VARIANTS: phf::Set<u32> = phf::phf_set![",
          *codes,
          "];\n"
        ]
      end
        .prepend("// Automatically generated by #{File.basename(__FILE__)} at #{Time.now.utc}\n")
        .join("\n")
  end

  def aliases
    @aliases ||= errcodes
      .values
      .map(&:values)
      .flatten
      .group_by { |code| code[:sqlstate] }
      .select { |_, codes| codes.count > 1 }
      .transform_values do |codes|
        codes.each_with_object({}) do |code, h|
          if code[:spec_name].nil?
            h[code[:name]] = :alias
          else
            h[:base_code] = code[:name]
          end
        end
      end
  end

  def errcodes
    @errcodes ||= lines
      .chunk_while { !_2.match(/^\s*Section:/) }
      .with_object(Hash.new { |h, k| h[k] = Hash.new }) do |(section, *codes), h|

        codes = codes
          .map(&:split)
          .map do |sqlstate, category, macro_name, spec_name|
            repr = sqlstate.bytes
              .map { |b| b - '0'.ord }
              .reduce { |acc, b| (acc << 6) | b }

            name = macro_name[8..-1] # remove 'ERRCODE_'
            name = name.downcase.gsub(/(?:^|_)(.)/) { |m| m[-1].upcase }
            { sqlstate:, category:, name:, spec_name:, repr: }
          end

        category = codes.first[:category]

        h[category][section] = codes
      end
  end

  def lines
    @lines ||= @input.readlines.tap do |f|
      f.reject! { _1.match?(/^\s*(#|$)/) }
    end.map!(&:chomp!);
  end

end

ErrCodesGenerator.run!($ARGV[0], $ARGV[1]) if __FILE__ == $PROGRAM_NAME
