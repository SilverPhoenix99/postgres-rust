
require 'pathname'
require 'set'
require_relative 'minimal_perfect_hash'

class KeywordsGenerator

  CATEGORIES = {
    'UNRESERVED_KEYWORD' => 'Unreserved',
    'COL_NAME_KEYWORD' => 'ColumnName',
    'TYPE_FUNC_NAME_KEYWORD' => 'TypeFuncName',
    'RESERVED_KEYWORD' => 'Reserved',
  }

  # Keywords that clash with Rust classes.
  # These will have a 'Kw' suffix.
  CLASHES = %w[
    Copy
    Default
    Drop
    Error
    Location
    None
    Option
    Owned
    Parser
    Range
    Ref
    Some
    Stdin
    Stdout
    String
    System
  ].to_set

  def self.run!(input, output)
    new(input, output).run!
  end

  def initialize(input, output)
    @input = Pathname(input)
    @output = Pathname(output)
  end

  def run!
    init_keywords_hash
    rendered = render
    @output.write(rendered)
  end

  def init_keywords_hash
    return if @intermediate

    keys = keywords.map { |kw| kw[:text] }
    @intermediate, slots = MinimalPerfectHash.generate!(keys)

    @keywords.each do |kw|
      kw[:slot] = slots[kw[:text]]
    end

    @keywords = @keywords.sort_by { |kw| kw[:slot] }

    nil
  end

  def render
    [
      "// Automatically generated by #{File.basename(__FILE__)} at #{Time.now.utc}",
      '',
      *render_max_length,
      '',
      *render_keyword_enum,
      '',
      *render_intermediate_array,
      '',
      *render_keyword_details,
      '',
      'use super::KeywordCategory::*;',
      'use super::KeywordDetails;',
      'use Keyword::*;',
      ''
    ].join("\n")
  end

  def render_max_length
    max_len = keywords.map { |kw| kw[:text].size }.max
    ["pub(super) const MAX_KEYWORD_LENGTH: usize = #{max_len};"]
  end

  def render_keyword_enum

    kws = keywords
      .sort_by { |kw| kw[:keyword] }
      .map { |kw| "    #{kw[:keyword]} = #{kw[:slot]}," }

    [
      '#[derive(Debug, Clone, Copy, Eq, PartialEq)]',
      "pub enum Keyword {",
      *kws,
      '}'
    ]
  end

  def render_intermediate_array

    values = @intermediate.each_slice(16)
      .map do |slice|
        slice = slice.map { |i| '%4s' % i }.join(', ')
        "    #{slice},"
      end

    [
      "pub(super) const INTERMEDIATE: [i16; #{@intermediate.size}] = [",
      *values,
      '];'
    ]
  end

  def render_keyword_details

    kw_details = keywords.map do |kw|
      text = kw[:text].inspect
      category = kw[:category]
      keyword = kw[:keyword]
      bare = kw[:bare]
      "    KeywordDetails::new(#{keyword}, #{text}, #{category}, #{bare}),"
    end

    [
      "pub(super) const KEYWORD_DETAILS: [KeywordDetails; #{keywords.length}] = [",
      *kw_details,
      '];'
    ]
  end

  def keywords
    @keywords ||= read_file
      .filter_map { |line| line.match(/^PG_KEYWORD\(\K([^)]+)/) }
      .map do |match|
        text, keyword, category, bare = match[0].split(/\s*,\s*/)
        keyword = keyword.sub(/_P$/, '').split('_').map(&:capitalize).join
        keyword += 'Kw' if CLASHES.include?(keyword)
        {
          text: text[1..-2], # remove quotes
          keyword:,
          category: CATEGORIES[category],
          bare: bare == 'BARE_LABEL'
        }
      end
  end

  def read_file
    @lines ||= @input.readlines
  end

end

KeywordsGenerator.run!($ARGV[0], $ARGV[1]) if __FILE__ == $PROGRAM_NAME
