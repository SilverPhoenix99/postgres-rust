####################################################################################################
# Generates the `Keyword` enum for the SQL keywords,
# and the corresponding minimal perfect Map.
####################################################################################################

require 'pathname'
require 'set'
require_relative 'minimal_perfect_hash'

class KeywordsGenerator

  class Keyword

    attr_reader :text,
                :keyword,
                :category,
                :bare

    attr_accessor :slot

    def initialize(text:, keyword:, category:, bare:)
      @text = text
      @category = category
      @bare = bare
      @keyword = keyword
    end
  end

  CATEGORIES = {
    'UNRESERVED_KEYWORD' => :Unreserved,
    'COL_NAME_KEYWORD' => :ColumnName,
    'TYPE_FUNC_NAME_KEYWORD' => :TypeFuncName,
    'RESERVED_KEYWORD' => :Reserved,
  }

  # Keywords that clash with Rust classes.
  # These will have a 'Kw' suffix.
  CLASHES = %w[
    Copy
    Default
    Drop
    Error
    From
    Location
    None
    Option
    Owned
    Parser
    Range
    Ref
    Some
    Stdin
    Stdout
    String
    System
  ].to_set

  def self.run!(input, output)
    new(input, output).run!
  end

  def initialize(input, output)
    @input = Pathname(input)
    @output = Pathname(output)
  end

  def run!
    init_keywords_hash
    rendered = render
    @output.binwrite(rendered)
  end

  def init_keywords_hash
    return if @table

    keys = keywords.map(&:text)
    @table = MinimalPerfectHash.generate!(keys)

    keywords.each do |kw|
      kw.slot = @table.slots[kw.text]
    end

    nil
  end

  def render
    [
      "// Automatically generated by #{File.basename(__FILE__)} at #{Time.now.utc}",
      '//',
      '// DO NOT EDIT MANUALLY !!!',
      '//',
      '',
      *render_keyword_enum,
      '',
      render_max_length,
      '',
      'pub(super) static MAP: mphf::Map<&str, KeywordDetails> = mphf::Map::new(&SALTS, &ENTRIES);',
      '',
      *render_keyword_details,
      '',
      *render_salts,
      '',
      'use super::KeywordCategory::*;',
      'use super::KeywordDetails;',
      'use pg_basics::mphf;',
      'use Keyword::*;',
      ''
    ].join("\n")
  end

  def render_keyword_enum

    kws = keywords
      .sort_by(&:keyword)
      .map { |kw| "    #{kw.keyword} = #{kw.slot}," }

    [
      '#[derive(Debug, Clone, Copy, Eq, PartialEq)]',
      "pub enum Keyword {",
      *kws,
      '}'
    ]
  end

  def render_keyword_details

    kw_details = keywords.sort_by(&:slot)
      .map do |kw|

        keyword = kw.keyword
        text = kw.text.inspect
        category = kw.category
        bare = kw.bare
        slot = kw.slot

        kw_detail = "KeywordDetails::new(#{keyword}, #{text}, #{category}, #{bare})"

        "    (#{text}, #{kw_detail}),"
      end

    [
      "pub(super) static ENTRIES: [(&str, KeywordDetails); #{keywords.length}] = [",
      *kw_details,
      '];'
    ]
  end

  def render_max_length
    max_len = keywords.map { |kw| kw.text.size }.max
    "pub(super) const MAX_KEYWORD_LENGTH: usize = #{max_len};"
  end

  def render_salts

    values = @table.salts.each_slice(16)
      .map do |slice|
        slice = slice.map { |i| '%4s' % i }.join(', ')
        "    #{slice},"
      end

    [
      "static SALTS: [i16; #{@table.salts.size}] = [",
      *values,
      '];'
    ]
  end

  def keywords
    @keywords ||= lines
      .filter_map { |line| line.match(/^PG_KEYWORD\(\K([^)]+)/) }
      .map do |match|
        text, keyword, category, bare = match[0].split(/\s*,\s*/)

        keyword = keyword.sub(/_P$/, '').split('_').map(&:capitalize).join
        keyword += 'Kw' if CLASHES.include?(keyword)

        Keyword.new(
          text: text[1..-2], # remove quotes
          keyword:,
          category: CATEGORIES[category],
          bare: bare == 'BARE_LABEL'
        )
      end
  end

  def lines
    @lines ||= @input.readlines
  end

end

KeywordsGenerator.run!($ARGV[0], $ARGV[1]) if __FILE__ == $PROGRAM_NAME
